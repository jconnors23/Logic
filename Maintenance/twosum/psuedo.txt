The Prompt:

"Given an array of integers nums and an integer target, 
return indices of the two numbers such that they add up to target. 
You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order."


Example 1:

Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
Example 2:

Input: nums = [3,2,4], target = 6
Output: [1,2]
Example 3:

Input: nums = [3,3], target = 6
Output: [0,1]


try all combos algo

iterate through nums from left to right, when at index compare index to all other indices to see if target reached 

record val of index and return comped index once reached 

for i in range len nums 

temp = nums[i]

for j in range len nums 

if temp + nums[j] == target && j != i then return arr[i, j]

brute force passed. 

we can optimize by not checking a combo that has already been checked

would we create a dictionary containing indice mappings then perform a lookup before doing double comparison?
 e.g. if i, j in indice mappings then we do not compare nums[j] to nums[i] we instead continue
